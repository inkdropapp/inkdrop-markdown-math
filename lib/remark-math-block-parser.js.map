{"version":3,"sources":["../src/remark-math-block-parser.js"],"names":["trim","require","module","exports","fencedCode","C_NEWLINE","C_TAB","C_SPACE","C_TILDE","C_TICK","MIN_FENCE_COUNT","CODE_INDENT_COUNT","eat","value","silent","self","settings","options","length","index","subvalue","fenceCount","marker","character","queue","content","exdentedContent","closing","exdentedClosing","now","gfm","charAt","column","offset","type","lang"],"mappings":"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","sourcesContent":["/**\n * @author Titus Wormer\n * @copyright 2015 Titus Wormer\n * @license MIT\n * @module remark:parse:tokenize:code-fenced\n * @fileoverview Tokenise fenced code.\n */\n\n'use strict';\n\n/* Dependencies. */\nvar trim = require('trim-trailing-lines');\n\n/* Expose. */\nmodule.exports = fencedCode;\n\n/* Characters */\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '$';\n\n/* Constants */\nvar MIN_FENCE_COUNT = 2;\nvar CODE_INDENT_COUNT = 4;\n\n/**\n * Tokenise fenced code.\n *\n * @property {Function} locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `code` node.\n */\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_NEWLINE ||\n      character === C_TILDE ||\n      character === C_TICK\n    ) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = closing = exdentedClosing = content = exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: 'math',\n    value: trim(exdentedContent)\n  });\n}\n"],"file":"remark-math-block-parser.js"}